// --------------------------------------------------------------------------------------------------------------------
// <copyright file="FileHelper.Locking.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.IO.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.IO.Recipes
{
    using System;
    using System.IO;
    using System.Threading;

    using OBeautifulCode.Assertion.Recipes;

#if !OBeautifulCodeIORecipesProject
    internal
#else
    public
#endif
    static partial class FileHelper
    {
        /// <summary>
        /// Determines if file can be written to.
        /// </summary>
        /// <param name="filePath">filePath to check.</param>
        /// <returns>True if the file can be written to, false if not.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="filePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="filePath"/> is whitespace or contains one or more invalid characters.</exception>
        /// <exception cref="NotSupportedException"><paramref name="filePath"/> is in an invalid format.</exception>
        public static bool CanWriteToFile(
            string filePath)
        {
            new { filePath }.AsArg().Must().NotBeNullNorWhiteSpace();

            try
            {
                using (new FileStream(filePath, FileMode.Open, FileAccess.Write, FileShare.ReadWrite))
                {
                    return true;
                }
            }
            catch (FileNotFoundException)
            {
                return true;
            }
            catch (UnauthorizedAccessException)
            {
                // File is read-only OR filePath is a directory OR the caller does not have the required permissions
                return false;
            }
            catch (IOException)
            {
                return false;
            }
        }

        /// <summary>
        /// Determines if a file is in use (there's a file handle to the file).
        /// </summary>
        /// <param name="filePath">The file to check.</param>
        /// <remarks>
        /// If path is too long or directory is not found, then the method returns false.
        /// </remarks>
        /// <returns>
        /// Returns true if the file is in use, false if not.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="filePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="filePath"/> is whitespace or contains one or more invalid characters.</exception>
        /// <exception cref="NotSupportedException"><paramref name="filePath"/> is in an invalid format.</exception>
        public static bool IsFileInUse(
            string filePath)
        {
            new { filePath }.AsArg().Must().NotBeNullNorWhiteSpace();

            try
            {
                using (File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.None))
                {
                    return false;
                }
            }
            catch (PathTooLongException)
            {
                return false;
            }
            catch (DirectoryNotFoundException)
            {
                return false;
            }
            catch (FileNotFoundException)
            {
                return false;
            }
            catch (UnauthorizedAccessException)
            {
                // filePath is a directory OR the caller does not have the required permissions
                return true;
            }
            catch (IOException)
            {
                // get more specific here?  here's what message should look like "Message = "The process cannot access the file 'c:\test.xml' because it is being used by another process."
                // this is typically what's thrown if file is locked
                return true;
            }
        }

        /// <summary>
        /// Waits a specified period of time for a file to become unlocked.
        /// </summary>
        /// <param name="filePath">path to file.</param>
        /// <param name="timeoutSeconds">maximum number of seconds to wait for file to become unlocked.</param>
        /// <remarks>
        /// If the path is too long or the directory does not exist, then this method returns true.
        /// </remarks>
        /// <returns>True if file is unlocked.  False if not.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="filePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="filePath"/> is whitespace or contains one or more invalid characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="timeoutSeconds"/> &lt; 1.</exception>
        /// <exception cref="NotSupportedException"><paramref name="filePath"/> is in an invalid format.</exception>
        public static bool WaitForUnlock(
            string filePath, 
            int timeoutSeconds)
        {
            new { filePath }.AsArg().Must().NotBeNullNorWhiteSpace();
            new { timeoutSeconds }.AsArg().Must().BeGreaterThanOrEqualTo(1);

            int elapsedSeconds = 0;
            do
            {
                if (!IsFileInUse(filePath))
                {
                    return true;
                }

                Thread.Sleep(1000);
                elapsedSeconds++;
            }
            while (elapsedSeconds <= timeoutSeconds);

            return false;
        }

        /// <summary>
        /// Waits a specified period of time for a file to become writable.
        /// </summary>
        /// <param name="filePath">path to file.</param>
        /// <param name="timeoutSeconds">maximum number of seconds to wait for file to become writable.</param>
        /// <remarks>
        /// If the path is too long or the directory does not exist, returns false.
        /// </remarks>
        /// <returns>True if file is writeable.  False if not.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="filePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="filePath"/> is whitespace or contains one or more invalid characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="timeoutSeconds"/> &lt; 1.</exception>
        /// <exception cref="PathTooLongException"><paramref name="filePath"/> exceeds the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
        /// <exception cref="DirectoryNotFoundException">The directory containing the file doesn't exist.</exception>
        /// <exception cref="NotSupportedException"><paramref name="filePath"/> is in an invalid format.</exception>
        public static bool WaitUntilFileIsWritable(
            string filePath,
            int timeoutSeconds)
        {
            new { filePath }.AsArg().Must().NotBeNullNorWhiteSpace();
            new { timeoutSeconds }.AsArg().Must().BeGreaterThanOrEqualTo(1);

            int elapsedSeconds = 0;
            do
            {
                if (CanWriteToFile(filePath))
                {
                    return true;
                }

                Thread.Sleep(1000);
                elapsedSeconds++;
            }
            while (elapsedSeconds <= timeoutSeconds);

            return false;
        }
    }
}